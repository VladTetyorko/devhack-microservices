package com.vladte.devhack.common.service.generations.impl;

import com.vladte.devhack.common.service.generations.QuestionParsingService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.List;

/**
 * Implementation of the QuestionParsingService interface for parsing generated text into question texts.
 */
@Service
public class QuestionParsingServiceImpl implements QuestionParsingService {

    private static final Logger log = LoggerFactory.getLogger(QuestionParsingServiceImpl.class);

    /**
     * Parse the generated text into a list of question texts.
     *
     * @param generatedText the text generated by the AI
     * @return a list of question texts
     */
    @Override
    public List<String> parseQuestionTexts(String generatedText) {
        log.debug("Parsing generated text of length: {} characters", generatedText.length());
        List<String> questions = new ArrayList<>();

        String[] lines = generatedText.split("\n");
        log.debug("Split text into {} lines", lines.length);

        StringBuilder currentQuestion = new StringBuilder();
        int questionCount = 0;

        for (String line : lines) {
            processLine(line, currentQuestion, questions, questionCount);
            if (isNewQuestionStart(line) && currentQuestion.length() > 0) {
                questionCount++;
            }
        }

        handleFinalQuestion(currentQuestion, questions, questionCount);

        log.info("Parsed {} questions from generated text", questions.size());
        return questions;
    }

    private void processLine(String line, StringBuilder currentQuestion, List<String> questions, int questionCount) {
        String trimmedLine = line.trim();
        if (isNewQuestionStart(trimmedLine)) {
            handleCurrentQuestion(currentQuestion, questions, questionCount);
            addNewQuestion(trimmedLine, currentQuestion);
        } else if (currentQuestion.length() > 0) {
            appendToCurrentQuestion(trimmedLine, currentQuestion);
        } else {
            log.trace("Skipping line: {}", trimmedLine);
        }
    }

    private boolean isNewQuestionStart(String line) {
        return line.startsWith("Question: ");
    }

    private void handleCurrentQuestion(StringBuilder currentQuestion, List<String> questions, int questionCount) {
        if (currentQuestion.length() > 0) {
            questions.add(currentQuestion.toString().trim());
            log.debug("Added question #{}: {}", questionCount,
                    currentQuestion.length() > 50 ? currentQuestion.substring(0, 47) + "..." : currentQuestion);
            currentQuestion.setLength(0);
        }
    }

    private void addNewQuestion(String line, StringBuilder currentQuestion) {
        String questionText = line.substring("Question: ".length());
        log.debug("Found new question starting with: {}",
                questionText.length() > 50 ? questionText.substring(0, 47) + "..." : questionText);
        currentQuestion.append(questionText);
    }

    private void appendToCurrentQuestion(String line, StringBuilder currentQuestion) {
        log.trace("Adding continuation line to current question: {}", line);
        currentQuestion.append(" ").append(line);
    }

    private void handleFinalQuestion(StringBuilder currentQuestion, List<String> questions, int questionCount) {
        if (currentQuestion.length() > 0) {
            questions.add(currentQuestion.toString().trim());
            log.debug("Added final question #{}: {}", questionCount,
                    currentQuestion.length() > 50 ? currentQuestion.substring(0, 47) + "..." : currentQuestion);
        }
    }
}